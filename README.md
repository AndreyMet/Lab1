## Задание по git 

#### Проверить, что версия git не ниже 2.10.x
```
git --version
```

### 1. Слияние веток без конфликтов (без merge-commit)
```
Создать ветку main1 из ветки main
Сделать merge ветки feature1 в ветку main1
```

### 2. Слияние веток без конфликтов (с merge-commit)
```
Создать ветку main2 из ветки main
Сделать merge ветки feature1 в ветку main2 с флагом no-fast-forward
```

### 3. Наложение изменений поверх ветки без конфликтов
```
Создать ветку main3 из ветки main
Сделать rebase ветки main3 на основании ветки feature1
```

### 4. Слияние избранных коммитов в ветку c конфликтами
```
Создать ветку main4 из ветки main
Сделать cherry-pick последнего коммита из ветки feature2 в ветку main4
```

### 5. Слияние веток с конфликтами
```
Создать ветку feature25 из ветки feature2
Сделать коммит с изменениями данных переменной p1 в Main.java
Сделать merge ветки feature1 в ветку feature25
```

### 6. Наложение изменений поверх ветки с конфликтами
```
Создать ветку feature26 из ветки feature2
Сделать коммит с изменениями данных переменной p1 в Main.java
Сделать rebase ветки feature26 на основании ветки feature1
(после git add * использовать git rebase --continue)
```

### 7. Измение локальной истории коммитов (объединение коммитов)
```Cоздать ветку feature3
Cделать в ветке feature3 два коммита
Вывести инфо о коммитах (git log)
Объединить два последних коммита в один (squash), присвоив новый commit-message 
Снова вывести инфо о коммитах (git log)
```

### 8. Добавление клиентского хука для проверки формата описаний коммитов
```
Разработать хук commit-msg и поместить в директорию .git/hooks
Хук должен возвращать 0, если сообщение соответствует маске "[TICKET-123] my commit message" 
	-может меняться номер тикета и текст сообщения; 
	-номер может быть числом от 1 до 999; 
	-сообщение должно содержать хотя бы один символ; 
	-сообщение и закрывающая скобка разделены пробелом;
	-сообщение должно начинаться с открывающей скобки.
Хук возвращает 1 во всех остальных случаях
Хук нужно написать на bash, используя grep с опциями -iqE
```

## Задание по maven

### 1. Установить maven 
```
Проверить версию: mvn —version
Если версия ниже, чем 3.5.2, провести установку. 
Прописать переменные среды: 
M2_HOME={путь до папки maven}
Path=%Path%:%M2_HOME%\bin
Проверить правильность установки: mvn —version
```

### 2. Инсталлировать архетип
```
Перейти в локальный репозиторий SBT-MEPhI или клонировать его заново.
Скачать изменения из удаленного репозитория: git fetch
Перейти в ветку company-archetype. 
Инсталлировать архетип: mvn clean install
Проверить наличие артефакта в локальном репозитории.
Путь до локального репозитория: mvn help:evaluate -Dexpression=settings.localRepository
```

### 3. Создать проект из архетипа company-archetype
``` mvn archetype:generate -DarchetypeGroupId=ru.sbt.sbt-mephi -DarchetypeArtifactId=company-archetype -DarchetypeVersion=1.0 ```

### 4. Скомпилировать проект
```
Перейти в директорию с созданным проектом (artifactId).
Скомпилировать проект: mvn clean compile
Проанализировать ошибки.
Добавить все необходимые зависимости в pom.xml, пока проект не скомпилируется успешно.
GAV (groupId:artifactId:version) зависимостей с нужными классами найти в интернете в maven central репозитории.
```

### 5. Инсталлировать проект в локальный репозиторий
``` 
	mvn clean install
Убедиться, что артефакт есть в локальном репозитории. 
```

### 6. Разбить проект на три модуля
![Структура проекта](/first_one.jpg)
``` 
Перенести каждый класс (Company, Main, Person) в отдельный дочерний модуль.
Для этого в корне проекта необходимо создать три директории для дочерних проектов со своими pom.xml.
Для родительского проекта изменить тип результирующего артефакта на pom.xml и добавить блок с модулями:
    <modules>
        <module>proj_company</module>
        <module>proj_main</module>
        <module>proj_person</module>
    </modules>
Указать зависимости (блок dependencies) между дочерними модулями (согласно диаграмме).
Вынести зависимости специфичные для дочерних проектов из родительского pom.xml в дочерние pom.xml.
Версию логгера вынести в property родительского pom.xml (свойства родительских проектов можно использоать в дочерних).
```

### 6.1.
```
Очиститить локальный репозиторий (удалить директорию с зависимостями).
Попробовать собрать дочерние проекты. Для этого выполнить mvp package из каждого дочернего проекта.
Проанализировать результат.
Попробовать собрать дочерние проекты (mvn package) из родительского проекта с использованием флагов -pl, -am (Reactor build).
Проанализировать результат.
```

### 7. Сконфигурировать сборку
```
Добавить в блок build родительского pom.xml конфигурацию для создания дополнительного jar с исходными кодами (sources.jar).
Добавить возможность создания executable jar файла. Для этого создать профайл, в котором настроить maven-jar-plugin для указания mainClass для manifest. 
Собрать проект.
Запустить собранный jar файл.
```

## Задание по модульным тестам

### 1. Установка архетипа. 
```
Перейти в ветку stack-archetype.
В ней находится мавен проект с исходными кодами архетипа.
Собрать проект, установить архетип в локальный репозиторий.
```

### 2. Генерация проекта из архетипа.
```
Выполнить генерацию проекта из установленного архетипа.
```

### 3. Добавить библиотеку для модульного тестирования "junit 4" в зависимости.
```
Найти GAV в maven central или другими способами. Добавить в pom.xml.
```

### 4. Покрыть модульными тестами класс Stack.
![Стэк](/stack.png)

```
Класс Stack реализует стэк (список элементов, организованный по принципу LIFO).
Необходимо добавить в класс StackTest модульные тесты для класса Stack (можно воспользоваться функционалом IDEA для генерации заглушек тестов под каждый метод класса;курсор в любом месте в классе->ПКМ->generate->Tests или курсор на имя класса->alt+enter->Tests).
Каждый модульный тест будет являться методом, помеченным аннотацией @Test.
Если в тесте нужно сделать проверку, необходимо использовать методы класса Assert (assertEquals, assertTrue, assertFalse и прочие).
Если ожидается, что тест должен выкинуть эксепшн, это следует указать в параметрах аннотации @Test(expected = ArithmeticException.class).
Создать отдельный метод с аннотацией @Before (будет выполняться перед каждым тестом) для конфигурирования тестовых данных. Можно сначала написать тесты без этого метода, а потом вынести в него дублирующийся код.
Аннотации @Test, @Before и класс Assert находятся в библиотеке junit.
При запуске тестов использовать вариант "with coverage". Добиться 100% покрытия по всем 3 показателям (классы, методы, линии).
```

## Задание по Jenkins

### 1. Запустить jenkins. 
```
Используя cmd, запустить виртуалку.
cd jenkinsv
vagrant up

Открыть в браузере http://localhost:8081.
login: admin
password: admin

Ознакомиться с интерфейсом.

```

### 2. Создать freestyle job.
```
Используя кнопку New Item, создать freestyle job, который будет выводит в консоль параметр, задаваемый при запуске.
General -> параметризованная сборка -> описать параметр
Сборка -> команда shell -> вывести параметр

Собрать job с параметром, найти указанный параметр в консольном выводе.
```

### 3. Создать пару login/password.
```
Раздел credentials -> ... -> добавить учетные данные
```

### 4. Интегрировать job с git репозиторием.
```
Управление исходным кодом -> git

url: https://github.com/KirpKK/SBT-MEPhI
login: KirpKK
password: спросить
(или использовать свои login и password)

Собирать ветку module-project.

Запустить job, ознакомиться с содержимым сборочной директории и консольным выводом.
```

### 5. Установить maven.
```
vagrant ssh
apt-get install maven
maven -v
```

### 6. Собрать проект с профайлом "build executable jar".
```
Сборка -> вызвать цели maven -> указать цели, указать путь до pom.xml
Сборка -> команда shell -> java -jar proj_main-1.0-SNAPSHOT-jar-with-dependencies.jar
Скачать fat-jar из сборочной директории.
```

## 7. Ansible
Задание по ansible можно найти в файле `ANSIBLE.md` рядом

